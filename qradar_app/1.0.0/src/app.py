
import requests
import asyncio
import json
import urllib3

from walkoff_app_sdk.app_base import AppBase

class QRadard5e4fa5a354b86670e3f039ace5141f5(AppBase):
    """
    Autogenerated class by Shuffler
    """

    __version__ = "1.0"
    app_name = "qradar_app"

    def __init__(self, redis, logger, console_logger=None):
        self.verify = False
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        super().__init__(redis, logger, console_logger)

    def post_add_offense_note(self, apikey, url, offense_id, headers="", queries="", body="", ssl_verify=False, to_file=False):#
        print(f"Started function post_add_offense_note")
        params={}
        request_headers={}
        url=f"{url}/siem/offenses/{offense_id}/notes"
        ssl_verify = True if str(ssl_verify).lower() == "true" or ssl_verify == "1" else False


        if apikey != " ": request_headers["SEC"] = apikey
        if isinstance(headers, dict):
            request_headers = headers
        elif len(headers) > 0:
            for header in str(headers).split("\n"):
                if ':' in header:
                    headersplit=header.split(':')
                    request_headers[headersplit[0].strip()] = ':'.join(headersplit[1:]).strip()
                elif '=' in header:
                    headersplit=header.split('=')
                    request_headers[headersplit[0].strip()] = '='.join(headersplit[1:]).strip()


        if len(queries) > 0:
            if queries[0] == "?" or queries[0] == "&":
                queries = queries[1:len(queries)]
            if queries[len(queries)-1] == "?" or queries[len(queries)-1] == "&":
                queries = queries[0:-1]
            for query in queries.split("&"):
                 if isinstance(query, list) or isinstance(query, dict):
                    try:
                        query = json.dumps(query)
                    except:
                        pass
                 if '=' in query:
                    headersplit=query.split('=')
                    params[requests.utils.quote(headersplit[0].strip())] = requests.utils.quote(headersplit[1].strip())
                 else:
                    params[requests.utils.quote(query.strip())] = None
        params = '&'.join([k if v is None else f"{k}={v}" for k, v in params.items()])
        try:
            body = " ".join(body.strip().split()).encode("utf-8")
        except:
            pass


        if str(to_file).lower() == "true":
            to_file = True
        else:
            to_file = False

        if "http:/" in url and not "http://" in url:
            url = url.replace("http:/", "http://", -1)
        if "https:/" in url and not "https://" in url:
            url = url.replace("https:/", "https://", -1)
        if "http:///" in url:
            url = url.replace("http:///", "http://", -1)
        if "https:///" in url:
            url = url.replace("https:///", "https://", -1)
        if not "http://" in url and not "http" in url:
            url = f"http://{url}"

        try:
            body = json.dumps(body)
        except:
            pass

        found = False
        contentType = ""
        for key, value in request_headers.items():
            if key.lower() == "user-agent":
                found = True
            if key.lower() == "content-type":
                contentType = key

        if len(contentType) > 0:
            pass

        if not found:
            request_headers["User-Agent"] = "Shuffle Automation"

        try:
            #parsed_headers = [sys.stdout.write(f" -H \"{key}: {value}\"") for key, value in request_headers.items()]
            parsed_headers = ""
            parsed_curl_command = f"curl -XPOST {url} {parsed_headers}"
            parsed_curl_command += f""" -d '{body}'""" if isinstance(body, str) else f""" -d '{body.decode("utf-8")}'"""

            self.action["parameters"].append({
                "name": "shuffle_request_url",
                "value": f"{url}",
            })
            self.action["parameters"].append({
                "name": "shuffle_request_curl",
                "value": f"{parsed_curl_command}",
            })
            self.action["parameters"].append({
                "name": "shuffle_request_headers",
                "value": f"{json.dumps(parsed_headers)}",
            })

            self.action_result["action"] = self.action
            print("[DEBUG] Updated values in self.action_result from OpenAPI app! (1)")
        except Exception as e:
            print(f"[WARNING] Something went wrong when adding extra returns (1). {e}")

        session = requests.Session()
        ret = session.post(url, headers=request_headers, params=params, data=body, verify=ssl_verify)
        try:
            found = False
            for item in self.action["parameters"]:
                if item["name"] == "shuffle_response_status":
                    found = True
                    break

            if not found:
                self.action["parameters"].append({
                    "name": "shuffle_response_status",
                    "value": f"{ret.status_code}",
                })
                self.action["parameters"].append({
                    "name": "shuffle_response_length",
                    "value": f"{len(ret.text)}",
                })
                self.action["parameters"].append({
                    "name": "shuffle_request_cookies",
                    "value": f"{json.dumps(session.cookies.get_dict())}",
                })
                print("[DEBUG] Updated values in self.action_result from OpenAPI app! (2)")

        except Exception as e:
            print(f"[WARNING] Something went wrong when adding extra returns (2). {e}")

        if to_file:
            # If content encoding or transfer encoding is base64, decode it
            if ("content-encoding" in ret.headers.keys() and "base64" in ret.headers["content-encoding"].lower()) or ("transfer-encoding" in ret.headers.keys() and "base64" in ret.headers["transfer-encoding"].lower()) or ("content-transfer-encoding" in ret.headers.keys() and "base64" in ret.headers["content-transfer-encoding"].lower()):
                print("[DEBUG] Content encoding is base64, decoding it")
                ret.content = base64.b64decode(ret.content)


            filedata = {
                "filename": "response",
                "data": ret.content,
            }

            fileret = self.set_files([filedata])
            if len(fileret) == 1:
                return {"success": True, "file_id": fileret[0], "status": ret.status_code}

            return fileret

        if not to_file:
            return self.prepare_response(ret)

        return ret.text

    def post_update_offense(self, apikey, url, offense_id, headers="", queries="", body="", ssl_verify=False, to_file=False):#
        print(f"Started function post_update_offense")
        params={}
        request_headers={}
        url=f"{url}/siem/offenses/{offense_id}"
        ssl_verify = True if str(ssl_verify).lower() == "true" or ssl_verify == "1" else False


        if apikey != " ": request_headers["SEC"] = apikey
        if isinstance(headers, dict):
            request_headers = headers
        elif len(headers) > 0:
            for header in str(headers).split("\n"):
                if ':' in header:
                    headersplit=header.split(':')
                    request_headers[headersplit[0].strip()] = ':'.join(headersplit[1:]).strip()
                elif '=' in header:
                    headersplit=header.split('=')
                    request_headers[headersplit[0].strip()] = '='.join(headersplit[1:]).strip()


        if len(queries) > 0:
            if queries[0] == "?" or queries[0] == "&":
                queries = queries[1:len(queries)]
            if queries[len(queries)-1] == "?" or queries[len(queries)-1] == "&":
                queries = queries[0:-1]
            for query in queries.split("&"):
                 if isinstance(query, list) or isinstance(query, dict):
                    try:
                        query = json.dumps(query)
                    except:
                        pass
                 if '=' in query:
                    headersplit=query.split('=')
                    params[requests.utils.quote(headersplit[0].strip())] = requests.utils.quote(headersplit[1].strip())
                 else:
                    params[requests.utils.quote(query.strip())] = None
        params = '&'.join([k if v is None else f"{k}={v}" for k, v in params.items()])
        try:
            body = " ".join(body.strip().split()).encode("utf-8")
        except:
            pass


        if str(to_file).lower() == "true":
            to_file = True
        else:
            to_file = False

        if "http:/" in url and not "http://" in url:
            url = url.replace("http:/", "http://", -1)
        if "https:/" in url and not "https://" in url:
            url = url.replace("https:/", "https://", -1)
        if "http:///" in url:
            url = url.replace("http:///", "http://", -1)
        if "https:///" in url:
            url = url.replace("https:///", "https://", -1)
        if not "http://" in url and not "http" in url:
            url = f"http://{url}"

        try:
            body = json.dumps(body)
        except:
            pass

        found = False
        contentType = ""
        for key, value in request_headers.items():
            if key.lower() == "user-agent":
                found = True
            if key.lower() == "content-type":
                contentType = key

        if len(contentType) > 0:
            pass

        if not found:
            request_headers["User-Agent"] = "Shuffle Automation"

        try:
            #parsed_headers = [sys.stdout.write(f" -H \"{key}: {value}\"") for key, value in request_headers.items()]
            parsed_headers = ""
            parsed_curl_command = f"curl -XPOST {url} {parsed_headers}"
            parsed_curl_command += f""" -d '{body}'""" if isinstance(body, str) else f""" -d '{body.decode("utf-8")}'"""

            self.action["parameters"].append({
                "name": "shuffle_request_url",
                "value": f"{url}",
            })
            self.action["parameters"].append({
                "name": "shuffle_request_curl",
                "value": f"{parsed_curl_command}",
            })
            self.action["parameters"].append({
                "name": "shuffle_request_headers",
                "value": f"{json.dumps(parsed_headers)}",
            })

            self.action_result["action"] = self.action
            print("[DEBUG] Updated values in self.action_result from OpenAPI app! (1)")
        except Exception as e:
            print(f"[WARNING] Something went wrong when adding extra returns (1). {e}")

        session = requests.Session()
        ret = session.post(url, headers=request_headers, params=params, data=body, verify=ssl_verify)
        try:
            found = False
            for item in self.action["parameters"]:
                if item["name"] == "shuffle_response_status":
                    found = True
                    break

            if not found:
                self.action["parameters"].append({
                    "name": "shuffle_response_status",
                    "value": f"{ret.status_code}",
                })
                self.action["parameters"].append({
                    "name": "shuffle_response_length",
                    "value": f"{len(ret.text)}",
                })
                self.action["parameters"].append({
                    "name": "shuffle_request_cookies",
                    "value": f"{json.dumps(session.cookies.get_dict())}",
                })
                print("[DEBUG] Updated values in self.action_result from OpenAPI app! (2)")

        except Exception as e:
            print(f"[WARNING] Something went wrong when adding extra returns (2). {e}")

        if to_file:
            # If content encoding or transfer encoding is base64, decode it
            if ("content-encoding" in ret.headers.keys() and "base64" in ret.headers["content-encoding"].lower()) or ("transfer-encoding" in ret.headers.keys() and "base64" in ret.headers["transfer-encoding"].lower()) or ("content-transfer-encoding" in ret.headers.keys() and "base64" in ret.headers["content-transfer-encoding"].lower()):
                print("[DEBUG] Content encoding is base64, decoding it")
                ret.content = base64.b64decode(ret.content)


            filedata = {
                "filename": "response",
                "data": ret.content,
            }

            fileret = self.set_files([filedata])
            if len(fileret) == 1:
                return {"success": True, "file_id": fileret[0], "status": ret.status_code}

            return fileret

        if not to_file:
            return self.prepare_response(ret)

        return ret.text

    def get_rules(self, apikey, url, headers="", queries="", fields="", filter="", ssl_verify=False, to_file=False):#
        print(f"Started function get_rules")
        params={}
        request_headers={"Accept": "application/json","Content-Type": "application/json"}
        url=f"{url}/analytics/rules"
        ssl_verify = True if str(ssl_verify).lower() == "true" or ssl_verify == "1" else False


        if apikey != " ": request_headers["SEC"] = apikey
        if isinstance(headers, dict):
            request_headers = headers
        elif len(headers) > 0:
            for header in str(headers).split("\n"):
                if ':' in header:
                    headersplit=header.split(':')
                    request_headers[headersplit[0].strip()] = ':'.join(headersplit[1:]).strip()
                elif '=' in header:
                    headersplit=header.split('=')
                    request_headers[headersplit[0].strip()] = '='.join(headersplit[1:]).strip()

        if fields:
            if isinstance(fields, list) or isinstance(fields, dict):
                try:
                    fields = json.dumps(fields)
                except:
                    pass

            params[requests.utils.quote("fields")] = requests.utils.quote(fields)
        if filter:
            if isinstance(filter, list) or isinstance(filter, dict):
                try:
                    filter = json.dumps(filter)
                except:
                    pass

            params[requests.utils.quote("filter")] = requests.utils.quote(filter)

        if len(queries) > 0:
            if queries[0] == "?" or queries[0] == "&":
                queries = queries[1:len(queries)]
            if queries[len(queries)-1] == "?" or queries[len(queries)-1] == "&":
                queries = queries[0:-1]
            for query in queries.split("&"):
                 if isinstance(query, list) or isinstance(query, dict):
                    try:
                        query = json.dumps(query)
                    except:
                        pass
                 if '=' in query:
                    headersplit=query.split('=')
                    params[requests.utils.quote(headersplit[0].strip())] = requests.utils.quote(headersplit[1].strip())
                 else:
                    params[requests.utils.quote(query.strip())] = None
        params = '&'.join([k if v is None else f"{k}={v}" for k, v in params.items()])



        if str(to_file).lower() == "true":
            to_file = True
        else:
            to_file = False

        if "http:/" in url and not "http://" in url:
            url = url.replace("http:/", "http://", -1)
        if "https:/" in url and not "https://" in url:
            url = url.replace("https:/", "https://", -1)
        if "http:///" in url:
            url = url.replace("http:///", "http://", -1)
        if "https:///" in url:
            url = url.replace("https:///", "https://", -1)
        if not "http://" in url and not "http" in url:
            url = f"http://{url}"

        try:
            body = json.dumps(body)
        except:
            pass

        found = False
        contentType = ""
        for key, value in request_headers.items():
            if key.lower() == "user-agent":
                found = True
            if key.lower() == "content-type":
                contentType = key

        if len(contentType) > 0:
            pass

        if not found:
            request_headers["User-Agent"] = "Shuffle Automation"

        try:
            #parsed_headers = [sys.stdout.write(f" -H \"{key}: {value}\"") for key, value in request_headers.items()]
            parsed_headers = ""
            parsed_curl_command = f"curl -XGET {url} {parsed_headers}"


            self.action["parameters"].append({
                "name": "shuffle_request_url",
                "value": f"{url}",
            })
            self.action["parameters"].append({
                "name": "shuffle_request_curl",
                "value": f"{parsed_curl_command}",
            })
            self.action["parameters"].append({
                "name": "shuffle_request_headers",
                "value": f"{json.dumps(parsed_headers)}",
            })

            self.action_result["action"] = self.action
            print("[DEBUG] Updated values in self.action_result from OpenAPI app! (1)")
        except Exception as e:
            print(f"[WARNING] Something went wrong when adding extra returns (1). {e}")

        session = requests.Session()
        ret = session.get(url, headers=request_headers, params=params, verify=ssl_verify)
        try:
            found = False
            for item in self.action["parameters"]:
                if item["name"] == "shuffle_response_status":
                    found = True
                    break

            if not found:
                self.action["parameters"].append({
                    "name": "shuffle_response_status",
                    "value": f"{ret.status_code}",
                })
                self.action["parameters"].append({
                    "name": "shuffle_response_length",
                    "value": f"{len(ret.text)}",
                })
                self.action["parameters"].append({
                    "name": "shuffle_request_cookies",
                    "value": f"{json.dumps(session.cookies.get_dict())}",
                })
                print("[DEBUG] Updated values in self.action_result from OpenAPI app! (2)")

        except Exception as e:
            print(f"[WARNING] Something went wrong when adding extra returns (2). {e}")

        if to_file:
            # If content encoding or transfer encoding is base64, decode it
            if ("content-encoding" in ret.headers.keys() and "base64" in ret.headers["content-encoding"].lower()) or ("transfer-encoding" in ret.headers.keys() and "base64" in ret.headers["transfer-encoding"].lower()) or ("content-transfer-encoding" in ret.headers.keys() and "base64" in ret.headers["content-transfer-encoding"].lower()):
                print("[DEBUG] Content encoding is base64, decoding it")
                ret.content = base64.b64decode(ret.content)


            filedata = {
                "filename": "response",
                "data": ret.content,
            }

            fileret = self.set_files([filedata])
            if len(fileret) == 1:
                return {"success": True, "file_id": fileret[0], "status": ret.status_code}

            return fileret

        if not to_file:
            return self.prepare_response(ret)

        return ret.text

    def delete_the_rule(self, apikey, url, id, headers="", queries="", body="", ssl_verify=False, to_file=False):#
        print(f"Started function delete_the_rule")
        params={}
        request_headers={}
        url=f"{url}/analytics/rules/{id}"
        ssl_verify = True if str(ssl_verify).lower() == "true" or ssl_verify == "1" else False


        if apikey != " ": request_headers["SEC"] = apikey
        if isinstance(headers, dict):
            request_headers = headers
        elif len(headers) > 0:
            for header in str(headers).split("\n"):
                if ':' in header:
                    headersplit=header.split(':')
                    request_headers[headersplit[0].strip()] = ':'.join(headersplit[1:]).strip()
                elif '=' in header:
                    headersplit=header.split('=')
                    request_headers[headersplit[0].strip()] = '='.join(headersplit[1:]).strip()


        if len(queries) > 0:
            if queries[0] == "?" or queries[0] == "&":
                queries = queries[1:len(queries)]
            if queries[len(queries)-1] == "?" or queries[len(queries)-1] == "&":
                queries = queries[0:-1]
            for query in queries.split("&"):
                 if isinstance(query, list) or isinstance(query, dict):
                    try:
                        query = json.dumps(query)
                    except:
                        pass
                 if '=' in query:
                    headersplit=query.split('=')
                    params[requests.utils.quote(headersplit[0].strip())] = requests.utils.quote(headersplit[1].strip())
                 else:
                    params[requests.utils.quote(query.strip())] = None
        params = '&'.join([k if v is None else f"{k}={v}" for k, v in params.items()])
        try:
            body = " ".join(body.strip().split()).encode("utf-8")
        except:
            pass


        if str(to_file).lower() == "true":
            to_file = True
        else:
            to_file = False

        if "http:/" in url and not "http://" in url:
            url = url.replace("http:/", "http://", -1)
        if "https:/" in url and not "https://" in url:
            url = url.replace("https:/", "https://", -1)
        if "http:///" in url:
            url = url.replace("http:///", "http://", -1)
        if "https:///" in url:
            url = url.replace("https:///", "https://", -1)
        if not "http://" in url and not "http" in url:
            url = f"http://{url}"

        try:
            body = json.dumps(body)
        except:
            pass

        found = False
        contentType = ""
        for key, value in request_headers.items():
            if key.lower() == "user-agent":
                found = True
            if key.lower() == "content-type":
                contentType = key

        if len(contentType) > 0:
            pass

        if not found:
            request_headers["User-Agent"] = "Shuffle Automation"

        try:
            #parsed_headers = [sys.stdout.write(f" -H \"{key}: {value}\"") for key, value in request_headers.items()]
            parsed_headers = ""
            parsed_curl_command = f"curl -XDELETE {url} {parsed_headers}"
            parsed_curl_command += f""" -d '{body}'""" if isinstance(body, str) else f""" -d '{body.decode("utf-8")}'"""

            self.action["parameters"].append({
                "name": "shuffle_request_url",
                "value": f"{url}",
            })
            self.action["parameters"].append({
                "name": "shuffle_request_curl",
                "value": f"{parsed_curl_command}",
            })
            self.action["parameters"].append({
                "name": "shuffle_request_headers",
                "value": f"{json.dumps(parsed_headers)}",
            })

            self.action_result["action"] = self.action
            print("[DEBUG] Updated values in self.action_result from OpenAPI app! (1)")
        except Exception as e:
            print(f"[WARNING] Something went wrong when adding extra returns (1). {e}")

        session = requests.Session()
        ret = session.delete(url, headers=request_headers, params=params, data=body, verify=ssl_verify)
        try:
            found = False
            for item in self.action["parameters"]:
                if item["name"] == "shuffle_response_status":
                    found = True
                    break

            if not found:
                self.action["parameters"].append({
                    "name": "shuffle_response_status",
                    "value": f"{ret.status_code}",
                })
                self.action["parameters"].append({
                    "name": "shuffle_response_length",
                    "value": f"{len(ret.text)}",
                })
                self.action["parameters"].append({
                    "name": "shuffle_request_cookies",
                    "value": f"{json.dumps(session.cookies.get_dict())}",
                })
                print("[DEBUG] Updated values in self.action_result from OpenAPI app! (2)")

        except Exception as e:
            print(f"[WARNING] Something went wrong when adding extra returns (2). {e}")

        if to_file:
            # If content encoding or transfer encoding is base64, decode it
            if ("content-encoding" in ret.headers.keys() and "base64" in ret.headers["content-encoding"].lower()) or ("transfer-encoding" in ret.headers.keys() and "base64" in ret.headers["transfer-encoding"].lower()) or ("content-transfer-encoding" in ret.headers.keys() and "base64" in ret.headers["content-transfer-encoding"].lower()):
                print("[DEBUG] Content encoding is base64, decoding it")
                ret.content = base64.b64decode(ret.content)


            filedata = {
                "filename": "response",
                "data": ret.content,
            }

            fileret = self.set_files([filedata])
            if len(fileret) == 1:
                return {"success": True, "file_id": fileret[0], "status": ret.status_code}

            return fileret

        if not to_file:
            return self.prepare_response(ret)

        return ret.text

    def get_rule_offense_contributions(self, apikey, url, headers="", queries="", filter="", sort="", fields="", ssl_verify=False, to_file=False):#
        print(f"Started function get_rule_offense_contributions")
        params={}
        request_headers={}
        url=f"{url}/analytics/rules_offense_contributions"
        ssl_verify = True if str(ssl_verify).lower() == "true" or ssl_verify == "1" else False


        if apikey != " ": request_headers["SEC"] = apikey
        if isinstance(headers, dict):
            request_headers = headers
        elif len(headers) > 0:
            for header in str(headers).split("\n"):
                if ':' in header:
                    headersplit=header.split(':')
                    request_headers[headersplit[0].strip()] = ':'.join(headersplit[1:]).strip()
                elif '=' in header:
                    headersplit=header.split('=')
                    request_headers[headersplit[0].strip()] = '='.join(headersplit[1:]).strip()

        if filter:
            if isinstance(filter, list) or isinstance(filter, dict):
                try:
                    filter = json.dumps(filter)
                except:
                    pass

            params[requests.utils.quote("filter")] = requests.utils.quote(filter)
        if sort:
            if isinstance(sort, list) or isinstance(sort, dict):
                try:
                    sort = json.dumps(sort)
                except:
                    pass

            params[requests.utils.quote("sort")] = requests.utils.quote(sort)
        if fields:
            if isinstance(fields, list) or isinstance(fields, dict):
                try:
                    fields = json.dumps(fields)
                except:
                    pass

            params[requests.utils.quote("fields")] = requests.utils.quote(fields)

        if len(queries) > 0:
            if queries[0] == "?" or queries[0] == "&":
                queries = queries[1:len(queries)]
            if queries[len(queries)-1] == "?" or queries[len(queries)-1] == "&":
                queries = queries[0:-1]
            for query in queries.split("&"):
                 if isinstance(query, list) or isinstance(query, dict):
                    try:
                        query = json.dumps(query)
                    except:
                        pass
                 if '=' in query:
                    headersplit=query.split('=')
                    params[requests.utils.quote(headersplit[0].strip())] = requests.utils.quote(headersplit[1].strip())
                 else:
                    params[requests.utils.quote(query.strip())] = None
        params = '&'.join([k if v is None else f"{k}={v}" for k, v in params.items()])



        if str(to_file).lower() == "true":
            to_file = True
        else:
            to_file = False

        if "http:/" in url and not "http://" in url:
            url = url.replace("http:/", "http://", -1)
        if "https:/" in url and not "https://" in url:
            url = url.replace("https:/", "https://", -1)
        if "http:///" in url:
            url = url.replace("http:///", "http://", -1)
        if "https:///" in url:
            url = url.replace("https:///", "https://", -1)
        if not "http://" in url and not "http" in url:
            url = f"http://{url}"

        try:
            body = json.dumps(body)
        except:
            pass

        found = False
        contentType = ""
        for key, value in request_headers.items():
            if key.lower() == "user-agent":
                found = True
            if key.lower() == "content-type":
                contentType = key

        if len(contentType) > 0:
            pass

        if not found:
            request_headers["User-Agent"] = "Shuffle Automation"

        try:
            #parsed_headers = [sys.stdout.write(f" -H \"{key}: {value}\"") for key, value in request_headers.items()]
            parsed_headers = ""
            parsed_curl_command = f"curl -XGET {url} {parsed_headers}"


            self.action["parameters"].append({
                "name": "shuffle_request_url",
                "value": f"{url}",
            })
            self.action["parameters"].append({
                "name": "shuffle_request_curl",
                "value": f"{parsed_curl_command}",
            })
            self.action["parameters"].append({
                "name": "shuffle_request_headers",
                "value": f"{json.dumps(parsed_headers)}",
            })

            self.action_result["action"] = self.action
            print("[DEBUG] Updated values in self.action_result from OpenAPI app! (1)")
        except Exception as e:
            print(f"[WARNING] Something went wrong when adding extra returns (1). {e}")

        session = requests.Session()
        ret = session.get(url, headers=request_headers, params=params, verify=ssl_verify)
        try:
            found = False
            for item in self.action["parameters"]:
                if item["name"] == "shuffle_response_status":
                    found = True
                    break

            if not found:
                self.action["parameters"].append({
                    "name": "shuffle_response_status",
                    "value": f"{ret.status_code}",
                })
                self.action["parameters"].append({
                    "name": "shuffle_response_length",
                    "value": f"{len(ret.text)}",
                })
                self.action["parameters"].append({
                    "name": "shuffle_request_cookies",
                    "value": f"{json.dumps(session.cookies.get_dict())}",
                })
                print("[DEBUG] Updated values in self.action_result from OpenAPI app! (2)")

        except Exception as e:
            print(f"[WARNING] Something went wrong when adding extra returns (2). {e}")

        if to_file:
            # If content encoding or transfer encoding is base64, decode it
            if ("content-encoding" in ret.headers.keys() and "base64" in ret.headers["content-encoding"].lower()) or ("transfer-encoding" in ret.headers.keys() and "base64" in ret.headers["transfer-encoding"].lower()) or ("content-transfer-encoding" in ret.headers.keys() and "base64" in ret.headers["content-transfer-encoding"].lower()):
                print("[DEBUG] Content encoding is base64, decoding it")
                ret.content = base64.b64decode(ret.content)


            filedata = {
                "filename": "response",
                "data": ret.content,
            }

            fileret = self.set_files([filedata])
            if len(fileret) == 1:
                return {"success": True, "file_id": fileret[0], "status": ret.status_code}

            return fileret

        if not to_file:
            return self.prepare_response(ret)

        return ret.text

    def get_ariel_searches(self, apikey, url, headers="", queries="", db_name="", data_lake="", filter="", ssl_verify=False, to_file=False):#    
        print(f"Started function get_ariel_searches")
        params={}
        request_headers={"Accept": "application/json","Content-Type": "application/json"}
        url=f"{url}/ariel/searches"
        ssl_verify = True if str(ssl_verify).lower() == "true" or ssl_verify == "1" else False


        if apikey != " ": request_headers["SEC"] = apikey
        if isinstance(headers, dict):
            request_headers = headers
        elif len(headers) > 0:
            for header in str(headers).split("\n"):
                if ':' in header:
                    headersplit=header.split(':')
                    request_headers[headersplit[0].strip()] = ':'.join(headersplit[1:]).strip()
                elif '=' in header:
                    headersplit=header.split('=')
                    request_headers[headersplit[0].strip()] = '='.join(headersplit[1:]).strip()

        if db_name:
            if isinstance(db_name, list) or isinstance(db_name, dict):
                try:
                    db_name = json.dumps(db_name)
                except:
                    pass

            params[requests.utils.quote("db_name")] = requests.utils.quote(db_name)
        if data_lake:
            if isinstance(data_lake, list) or isinstance(data_lake, dict):
                try:
                    data_lake = json.dumps(data_lake)
                except:
                    pass

            params[requests.utils.quote("data_lake")] = requests.utils.quote(data_lake)
        if filter:
            if isinstance(filter, list) or isinstance(filter, dict):
                try:
                    filter = json.dumps(filter)
                except:
                    pass

            params[requests.utils.quote("filter")] = requests.utils.quote(filter)

        if len(queries) > 0:
            if queries[0] == "?" or queries[0] == "&":
                queries = queries[1:len(queries)]
            if queries[len(queries)-1] == "?" or queries[len(queries)-1] == "&":
                queries = queries[0:-1]
            for query in queries.split("&"):
                 if isinstance(query, list) or isinstance(query, dict):
                    try:
                        query = json.dumps(query)
                    except:
                        pass
                 if '=' in query:
                    headersplit=query.split('=')
                    params[requests.utils.quote(headersplit[0].strip())] = requests.utils.quote(headersplit[1].strip())
                 else:
                    params[requests.utils.quote(query.strip())] = None
        params = '&'.join([k if v is None else f"{k}={v}" for k, v in params.items()])



        if str(to_file).lower() == "true":
            to_file = True
        else:
            to_file = False

        if "http:/" in url and not "http://" in url:
            url = url.replace("http:/", "http://", -1)
        if "https:/" in url and not "https://" in url:
            url = url.replace("https:/", "https://", -1)
        if "http:///" in url:
            url = url.replace("http:///", "http://", -1)
        if "https:///" in url:
            url = url.replace("https:///", "https://", -1)
        if not "http://" in url and not "http" in url:
            url = f"http://{url}"

        try:
            body = json.dumps(body)
        except:
            pass

        found = False
        contentType = ""
        for key, value in request_headers.items():
            if key.lower() == "user-agent":
                found = True
            if key.lower() == "content-type":
                contentType = key

        if len(contentType) > 0:
            pass

        if not found:
            request_headers["User-Agent"] = "Shuffle Automation"

        try:
            #parsed_headers = [sys.stdout.write(f" -H \"{key}: {value}\"") for key, value in request_headers.items()]
            parsed_headers = ""
            parsed_curl_command = f"curl -XGET {url} {parsed_headers}"


            self.action["parameters"].append({
                "name": "shuffle_request_url",
                "value": f"{url}",
            })
            self.action["parameters"].append({
                "name": "shuffle_request_curl",
                "value": f"{parsed_curl_command}",
            })
            self.action["parameters"].append({
                "name": "shuffle_request_headers",
                "value": f"{json.dumps(parsed_headers)}",
            })

            self.action_result["action"] = self.action
            print("[DEBUG] Updated values in self.action_result from OpenAPI app! (1)")
        except Exception as e:
            print(f"[WARNING] Something went wrong when adding extra returns (1). {e}")

        session = requests.Session()
        ret = session.get(url, headers=request_headers, params=params, verify=ssl_verify)
        try:
            found = False
            for item in self.action["parameters"]:
                if item["name"] == "shuffle_response_status":
                    found = True
                    break

            if not found:
                self.action["parameters"].append({
                    "name": "shuffle_response_status",
                    "value": f"{ret.status_code}",
                })
                self.action["parameters"].append({
                    "name": "shuffle_response_length",
                    "value": f"{len(ret.text)}",
                })
                self.action["parameters"].append({
                    "name": "shuffle_request_cookies",
                    "value": f"{json.dumps(session.cookies.get_dict())}",
                })
                print("[DEBUG] Updated values in self.action_result from OpenAPI app! (2)")

        except Exception as e:
            print(f"[WARNING] Something went wrong when adding extra returns (2). {e}")

        if to_file:
            # If content encoding or transfer encoding is base64, decode it
            if ("content-encoding" in ret.headers.keys() and "base64" in ret.headers["content-encoding"].lower()) or ("transfer-encoding" in ret.headers.keys() and "base64" in ret.headers["transfer-encoding"].lower()) or ("content-transfer-encoding" in ret.headers.keys() and "base64" in ret.headers["content-transfer-encoding"].lower()):
                print("[DEBUG] Content encoding is base64, decoding it")
                ret.content = base64.b64decode(ret.content)


            filedata = {
                "filename": "response",
                "data": ret.content,
            }

            fileret = self.set_files([filedata])
            if len(fileret) == 1:
                return {"success": True, "file_id": fileret[0], "status": ret.status_code}

            return fileret

        if not to_file:
            return self.prepare_response(ret)

        return ret.text

    def post_new_search(self, apikey, url, headers="", queries="", query_expression="", body="", ssl_verify=False, to_file=False):#-
        print(f"Started function post_new_search")
        params={}
        request_headers={}
        url=f"{url}/ariel/searches"
        ssl_verify = True if str(ssl_verify).lower() == "true" or ssl_verify == "1" else False


        if apikey != " ": request_headers["SEC"] = apikey
        if isinstance(headers, dict):
            request_headers = headers
        elif len(headers) > 0:
            for header in str(headers).split("\n"):
                if ':' in header:
                    headersplit=header.split(':')
                    request_headers[headersplit[0].strip()] = ':'.join(headersplit[1:]).strip()
                elif '=' in header:
                    headersplit=header.split('=')
                    request_headers[headersplit[0].strip()] = '='.join(headersplit[1:]).strip()

        if query_expression:
            if isinstance(query_expression, list) or isinstance(query_expression, dict):
                try:
                    query_expression = json.dumps(query_expression)
                except:
                    pass

            params[requests.utils.quote("query_expression")] = requests.utils.quote(query_expression)

        if len(queries) > 0:
            if queries[0] == "?" or queries[0] == "&":
                queries = queries[1:len(queries)]
            if queries[len(queries)-1] == "?" or queries[len(queries)-1] == "&":
                queries = queries[0:-1]
            for query in queries.split("&"):
                 if isinstance(query, list) or isinstance(query, dict):
                    try:
                        query = json.dumps(query)
                    except:
                        pass
                 if '=' in query:
                    headersplit=query.split('=')
                    params[requests.utils.quote(headersplit[0].strip())] = requests.utils.quote(headersplit[1].strip())
                 else:
                    params[requests.utils.quote(query.strip())] = None
        params = '&'.join([k if v is None else f"{k}={v}" for k, v in params.items()])
        try:
            body = " ".join(body.strip().split()).encode("utf-8")
        except:
            pass


        if str(to_file).lower() == "true":
            to_file = True
        else:
            to_file = False

        if "http:/" in url and not "http://" in url:
            url = url.replace("http:/", "http://", -1)
        if "https:/" in url and not "https://" in url:
            url = url.replace("https:/", "https://", -1)
        if "http:///" in url:
            url = url.replace("http:///", "http://", -1)
        if "https:///" in url:
            url = url.replace("https:///", "https://", -1)
        if not "http://" in url and not "http" in url:
            url = f"http://{url}"

        try:
            body = json.dumps(body)
        except:
            pass

        found = False
        contentType = ""
        for key, value in request_headers.items():
            if key.lower() == "user-agent":
                found = True
            if key.lower() == "content-type":
                contentType = key

        if len(contentType) > 0:
            pass

        if not found:
            request_headers["User-Agent"] = "Shuffle Automation"

        try:
            #parsed_headers = [sys.stdout.write(f" -H \"{key}: {value}\"") for key, value in request_headers.items()]
            parsed_headers = ""
            parsed_curl_command = f"curl -XPOST {url} {parsed_headers}"
            parsed_curl_command += f""" -d '{body}'""" if isinstance(body, str) else f""" -d '{body.decode("utf-8")}'"""

            self.action["parameters"].append({
                "name": "shuffle_request_url",
                "value": f"{url}",
            })
            self.action["parameters"].append({
                "name": "shuffle_request_curl",
                "value": f"{parsed_curl_command}",
            })
            self.action["parameters"].append({
                "name": "shuffle_request_headers",
                "value": f"{json.dumps(parsed_headers)}",
            })

            self.action_result["action"] = self.action
            print("[DEBUG] Updated values in self.action_result from OpenAPI app! (1)")
        except Exception as e:
            print(f"[WARNING] Something went wrong when adding extra returns (1). {e}")

        session = requests.Session()
        ret = session.post(url, headers=request_headers, params=params, data=body, verify=ssl_verify)
        try:
            found = False
            for item in self.action["parameters"]:
                if item["name"] == "shuffle_response_status":
                    found = True
                    break

            if not found:
                self.action["parameters"].append({
                    "name": "shuffle_response_status",
                    "value": f"{ret.status_code}",
                })
                self.action["parameters"].append({
                    "name": "shuffle_response_length",
                    "value": f"{len(ret.text)}",
                })
                self.action["parameters"].append({
                    "name": "shuffle_request_cookies",
                    "value": f"{json.dumps(session.cookies.get_dict())}",
                })
                print("[DEBUG] Updated values in self.action_result from OpenAPI app! (2)")

        except Exception as e:
            print(f"[WARNING] Something went wrong when adding extra returns (2). {e}")

        if to_file:
            # If content encoding or transfer encoding is base64, decode it
            if ("content-encoding" in ret.headers.keys() and "base64" in ret.headers["content-encoding"].lower()) or ("transfer-encoding" in ret.headers.keys() and "base64" in ret.headers["transfer-encoding"].lower()) or ("content-transfer-encoding" in ret.headers.keys() and "base64" in ret.headers["content-transfer-encoding"].lower()):
                print("[DEBUG] Content encoding is base64, decoding it")
                ret.content = base64.b64decode(ret.content)


            filedata = {
                "filename": "response",
                "data": ret.content,
            }

            fileret = self.set_files([filedata])
            if len(fileret) == 1:
                return {"success": True, "file_id": fileret[0], "status": ret.status_code}

            return fileret

        if not to_file:
            return self.prepare_response(ret)

        return ret.text

    def get_ariel_search_results(self, apikey, url, search_id, headers="", queries="", data_lake="", ssl_verify=False, to_file=False):#
        print(f"Started function get_ariel_search_results")
        params={}
        request_headers={"Accept": "application/json","Content-Type": "application/json"}
        url=f"{url}/ariel/searches/{search_id}/results"
        ssl_verify = True if str(ssl_verify).lower() == "true" or ssl_verify == "1" else False


        if apikey != " ": request_headers["SEC"] = apikey
        if isinstance(headers, dict):
            request_headers = headers
        elif len(headers) > 0:
            for header in str(headers).split("\n"):
                if ':' in header:
                    headersplit=header.split(':')
                    request_headers[headersplit[0].strip()] = ':'.join(headersplit[1:]).strip()
                elif '=' in header:
                    headersplit=header.split('=')
                    request_headers[headersplit[0].strip()] = '='.join(headersplit[1:]).strip()

        if data_lake:
            if isinstance(data_lake, list) or isinstance(data_lake, dict):
                try:
                    data_lake = json.dumps(data_lake)
                except:
                    pass

            params[requests.utils.quote("data_lake")] = requests.utils.quote(data_lake)

        if len(queries) > 0:
            if queries[0] == "?" or queries[0] == "&":
                queries = queries[1:len(queries)]
            if queries[len(queries)-1] == "?" or queries[len(queries)-1] == "&":
                queries = queries[0:-1]
            for query in queries.split("&"):
                 if isinstance(query, list) or isinstance(query, dict):
                    try:
                        query = json.dumps(query)
                    except:
                        pass
                 if '=' in query:
                    headersplit=query.split('=')
                    params[requests.utils.quote(headersplit[0].strip())] = requests.utils.quote(headersplit[1].strip())
                 else:
                    params[requests.utils.quote(query.strip())] = None
        params = '&'.join([k if v is None else f"{k}={v}" for k, v in params.items()])



        if str(to_file).lower() == "true":
            to_file = True
        else:
            to_file = False

        if "http:/" in url and not "http://" in url:
            url = url.replace("http:/", "http://", -1)
        if "https:/" in url and not "https://" in url:
            url = url.replace("https:/", "https://", -1)
        if "http:///" in url:
            url = url.replace("http:///", "http://", -1)
        if "https:///" in url:
            url = url.replace("https:///", "https://", -1)
        if not "http://" in url and not "http" in url:
            url = f"http://{url}"

        try:
            body = json.dumps(body)
        except:
            pass

        found = False
        contentType = ""
        for key, value in request_headers.items():
            if key.lower() == "user-agent":
                found = True
            if key.lower() == "content-type":
                contentType = key

        if len(contentType) > 0:
            pass

        if not found:
            request_headers["User-Agent"] = "Shuffle Automation"

        try:
            #parsed_headers = [sys.stdout.write(f" -H \"{key}: {value}\"") for key, value in request_headers.items()]
            parsed_headers = ""
            parsed_curl_command = f"curl -XGET {url} {parsed_headers}"


            self.action["parameters"].append({
                "name": "shuffle_request_url",
                "value": f"{url}",
            })
            self.action["parameters"].append({
                "name": "shuffle_request_curl",
                "value": f"{parsed_curl_command}",
            })
            self.action["parameters"].append({
                "name": "shuffle_request_headers",
                "value": f"{json.dumps(parsed_headers)}",
            })

            self.action_result["action"] = self.action
            print("[DEBUG] Updated values in self.action_result from OpenAPI app! (1)")
        except Exception as e:
            print(f"[WARNING] Something went wrong when adding extra returns (1). {e}")

        session = requests.Session()
        ret = session.get(url, headers=request_headers, params=params, verify=ssl_verify)
        try:
            found = False
            for item in self.action["parameters"]:
                if item["name"] == "shuffle_response_status":
                    found = True
                    break

            if not found:
                self.action["parameters"].append({
                    "name": "shuffle_response_status",
                    "value": f"{ret.status_code}",
                })
                self.action["parameters"].append({
                    "name": "shuffle_response_length",
                    "value": f"{len(ret.text)}",
                })
                self.action["parameters"].append({
                    "name": "shuffle_request_cookies",
                    "value": f"{json.dumps(session.cookies.get_dict())}",
                })
                print("[DEBUG] Updated values in self.action_result from OpenAPI app! (2)")

        except Exception as e:
            print(f"[WARNING] Something went wrong when adding extra returns (2). {e}")

        if to_file:
            # If content encoding or transfer encoding is base64, decode it
            if ("content-encoding" in ret.headers.keys() and "base64" in ret.headers["content-encoding"].lower()) or ("transfer-encoding" in ret.headers.keys() and "base64" in ret.headers["transfer-encoding"].lower()) or ("content-transfer-encoding" in ret.headers.keys() and "base64" in ret.headers["content-transfer-encoding"].lower()):
                print("[DEBUG] Content encoding is base64, decoding it")
                ret.content = base64.b64decode(ret.content)


            filedata = {
                "filename": "response",
                "data": ret.content,
            }

            fileret = self.set_files([filedata])
            if len(fileret) == 1:
                return {"success": True, "file_id": fileret[0], "status": ret.status_code}

            return fileret

        if not to_file:
            return self.prepare_response(ret)

        return ret.text

    def get_list_offenses(self, apikey, url, headers="", queries="", ssl_verify=False, to_file=False):#
        print(f"Started function get_list_offenses")
        params={}
        request_headers={}
        url=f"{url}/siem/offenses"
        ssl_verify = True if str(ssl_verify).lower() == "true" or ssl_verify == "1" else False


        if apikey != " ": request_headers["SEC"] = apikey
        if isinstance(headers, dict):
            request_headers = headers
        elif len(headers) > 0:
            for header in str(headers).split("\n"):
                if ':' in header:
                    headersplit=header.split(':')
                    request_headers[headersplit[0].strip()] = ':'.join(headersplit[1:]).strip()
                elif '=' in header:
                    headersplit=header.split('=')
                    request_headers[headersplit[0].strip()] = '='.join(headersplit[1:]).strip()


        if len(queries) > 0:
            if queries[0] == "?" or queries[0] == "&":
                queries = queries[1:len(queries)]
            if queries[len(queries)-1] == "?" or queries[len(queries)-1] == "&":
                queries = queries[0:-1]
            for query in queries.split("&"):
                 if isinstance(query, list) or isinstance(query, dict):
                    try:
                        query = json.dumps(query)
                    except:
                        pass
                 if '=' in query:
                    headersplit=query.split('=')
                    params[requests.utils.quote(headersplit[0].strip())] = requests.utils.quote(headersplit[1].strip())
                 else:
                    params[requests.utils.quote(query.strip())] = None
        params = '&'.join([k if v is None else f"{k}={v}" for k, v in params.items()])



        if str(to_file).lower() == "true":
            to_file = True
        else:
            to_file = False

        if "http:/" in url and not "http://" in url:
            url = url.replace("http:/", "http://", -1)
        if "https:/" in url and not "https://" in url:
            url = url.replace("https:/", "https://", -1)
        if "http:///" in url:
            url = url.replace("http:///", "http://", -1)
        if "https:///" in url:
            url = url.replace("https:///", "https://", -1)
        if not "http://" in url and not "http" in url:
            url = f"http://{url}"

        try:
            body = json.dumps(body)
        except:
            pass

        found = False
        contentType = ""
        for key, value in request_headers.items():
            if key.lower() == "user-agent":
                found = True
            if key.lower() == "content-type":
                contentType = key

        if len(contentType) > 0:
            pass

        if not found:
            request_headers["User-Agent"] = "Shuffle Automation"

        try:
            #parsed_headers = [sys.stdout.write(f" -H \"{key}: {value}\"") for key, value in request_headers.items()]
            parsed_headers = ""
            parsed_curl_command = f"curl -XGET {url} {parsed_headers}"


            self.action["parameters"].append({
                "name": "shuffle_request_url",
                "value": f"{url}",
            })
            self.action["parameters"].append({
                "name": "shuffle_request_curl",
                "value": f"{parsed_curl_command}",
            })
            self.action["parameters"].append({
                "name": "shuffle_request_headers",
                "value": f"{json.dumps(parsed_headers)}",
            })

            self.action_result["action"] = self.action
            print("[DEBUG] Updated values in self.action_result from OpenAPI app! (1)")
        except Exception as e:
            print(f"[WARNING] Something went wrong when adding extra returns (1). {e}")

        session = requests.Session()
        ret = session.get(url, headers=request_headers, params=params, verify=ssl_verify)
        try:
            found = False
            for item in self.action["parameters"]:
                if item["name"] == "shuffle_response_status":
                    found = True
                    break

            if not found:
                self.action["parameters"].append({
                    "name": "shuffle_response_status",
                    "value": f"{ret.status_code}",
                })
                self.action["parameters"].append({
                    "name": "shuffle_response_length",
                    "value": f"{len(ret.text)}",
                })
                self.action["parameters"].append({
                    "name": "shuffle_request_cookies",
                    "value": f"{json.dumps(session.cookies.get_dict())}",
                })
                print("[DEBUG] Updated values in self.action_result from OpenAPI app! (2)")

        except Exception as e:
            print(f"[WARNING] Something went wrong when adding extra returns (2). {e}")

        if to_file:
            # If content encoding or transfer encoding is base64, decode it
            if ("content-encoding" in ret.headers.keys() and "base64" in ret.headers["content-encoding"].lower()) or ("transfer-encoding" in ret.headers.keys() and "base64" in ret.headers["transfer-encoding"].lower()) or ("content-transfer-encoding" in ret.headers.keys() and "base64" in ret.headers["content-transfer-encoding"].lower()):
                print("[DEBUG] Content encoding is base64, decoding it")
                ret.content = base64.b64decode(ret.content)


            filedata = {
                "filename": "response",
                "data": ret.content,
            }

            fileret = self.set_files([filedata])
            if len(fileret) == 1:
                return {"success": True, "file_id": fileret[0], "status": ret.status_code}

            return fileret

        if not to_file:
            return self.prepare_response(ret)

        return ret.text

    def get_rule(self, apikey, url, id, headers="", queries="", fields="", ssl_verify=False, to_file=False):#-
        print(f"Started function get_rule")
        params={}
        request_headers={"Accept": "application/json","Content-Type": "application/json"}
        url=f"{url}/analytics/rules/{id}"
        ssl_verify = True if str(ssl_verify).lower() == "true" or ssl_verify == "1" else False


        if apikey != " ": request_headers["SEC"] = apikey
        if isinstance(headers, dict):
            request_headers = headers
        elif len(headers) > 0:
            for header in str(headers).split("\n"):
                if ':' in header:
                    headersplit=header.split(':')
                    request_headers[headersplit[0].strip()] = ':'.join(headersplit[1:]).strip()
                elif '=' in header:
                    headersplit=header.split('=')
                    request_headers[headersplit[0].strip()] = '='.join(headersplit[1:]).strip()

        if fields:
            if isinstance(fields, list) or isinstance(fields, dict):
                try:
                    fields = json.dumps(fields)
                except:
                    pass

            params[requests.utils.quote("fields")] = requests.utils.quote(fields)

        if len(queries) > 0:
            if queries[0] == "?" or queries[0] == "&":
                queries = queries[1:len(queries)]
            if queries[len(queries)-1] == "?" or queries[len(queries)-1] == "&":
                queries = queries[0:-1]
            for query in queries.split("&"):
                 if isinstance(query, list) or isinstance(query, dict):
                    try:
                        query = json.dumps(query)
                    except:
                        pass
                 if '=' in query:
                    headersplit=query.split('=')
                    params[requests.utils.quote(headersplit[0].strip())] = requests.utils.quote(headersplit[1].strip())
                 else:
                    params[requests.utils.quote(query.strip())] = None
        params = '&'.join([k if v is None else f"{k}={v}" for k, v in params.items()])



        if str(to_file).lower() == "true":
            to_file = True
        else:
            to_file = False

        if "http:/" in url and not "http://" in url:
            url = url.replace("http:/", "http://", -1)
        if "https:/" in url and not "https://" in url:
            url = url.replace("https:/", "https://", -1)
        if "http:///" in url:
            url = url.replace("http:///", "http://", -1)
        if "https:///" in url:
            url = url.replace("https:///", "https://", -1)
        if not "http://" in url and not "http" in url:
            url = f"http://{url}"

        try:
            body = json.dumps(body)
        except:
            pass

        found = False
        contentType = ""
        for key, value in request_headers.items():
            if key.lower() == "user-agent":
                found = True
            if key.lower() == "content-type":
                contentType = key

        if len(contentType) > 0:
            pass

        if not found:
            request_headers["User-Agent"] = "Shuffle Automation"

        try:
            #parsed_headers = [sys.stdout.write(f" -H \"{key}: {value}\"") for key, value in request_headers.items()]
            parsed_headers = ""
            parsed_curl_command = f"curl -XGET {url} {parsed_headers}"


            self.action["parameters"].append({
                "name": "shuffle_request_url",
                "value": f"{url}",
            })
            self.action["parameters"].append({
                "name": "shuffle_request_curl",
                "value": f"{parsed_curl_command}",
            })
            self.action["parameters"].append({
                "name": "shuffle_request_headers",
                "value": f"{json.dumps(parsed_headers)}",
            })

            self.action_result["action"] = self.action
            print("[DEBUG] Updated values in self.action_result from OpenAPI app! (1)")
        except Exception as e:
            print(f"[WARNING] Something went wrong when adding extra returns (1). {e}")

        session = requests.Session()
        ret = session.get(url, headers=request_headers, params=params, verify=ssl_verify)
        try:
            found = False
            for item in self.action["parameters"]:
                if item["name"] == "shuffle_response_status":
                    found = True
                    break

            if not found:
                self.action["parameters"].append({
                    "name": "shuffle_response_status",
                    "value": f"{ret.status_code}",
                })
                self.action["parameters"].append({
                    "name": "shuffle_response_length",
                    "value": f"{len(ret.text)}",
                })
                self.action["parameters"].append({
                    "name": "shuffle_request_cookies",
                    "value": f"{json.dumps(session.cookies.get_dict())}",
                })
                print("[DEBUG] Updated values in self.action_result from OpenAPI app! (2)")

        except Exception as e:
            print(f"[WARNING] Something went wrong when adding extra returns (2). {e}")

        if to_file:
            # If content encoding or transfer encoding is base64, decode it
            if ("content-encoding" in ret.headers.keys() and "base64" in ret.headers["content-encoding"].lower()) or ("transfer-encoding" in ret.headers.keys() and "base64" in ret.headers["transfer-encoding"].lower()) or ("content-transfer-encoding" in ret.headers.keys() and "base64" in ret.headers["content-transfer-encoding"].lower()):
                print("[DEBUG] Content encoding is base64, decoding it")
                ret.content = base64.b64decode(ret.content)


            filedata = {
                "filename": "response",
                "data": ret.content,
            }

            fileret = self.set_files([filedata])
            if len(fileret) == 1:
                return {"success": True, "file_id": fileret[0], "status": ret.status_code}

            return fileret

        if not to_file:
            return self.prepare_response(ret)

        return ret.text

    def delete_the_rule(self, apikey, url, id, headers="", queries="", body="", ssl_verify=False, to_file=False):
        print(f"Started function delete_the_rule")
        params={}
        request_headers={}
        url=f"{url}/analytics/rules/{id}"
        ssl_verify = True if str(ssl_verify).lower() == "true" or ssl_verify == "1" else False


        if apikey != " ": request_headers["SEC"] = apikey
        if isinstance(headers, dict):
            request_headers = headers
        elif len(headers) > 0:
            for header in str(headers).split("\n"):
                if ':' in header:
                    headersplit=header.split(':')
                    request_headers[headersplit[0].strip()] = ':'.join(headersplit[1:]).strip()
                elif '=' in header:
                    headersplit=header.split('=')
                    request_headers[headersplit[0].strip()] = '='.join(headersplit[1:]).strip()


        if len(queries) > 0:
            if queries[0] == "?" or queries[0] == "&":
                queries = queries[1:len(queries)]
            if queries[len(queries)-1] == "?" or queries[len(queries)-1] == "&":
                queries = queries[0:-1]
            for query in queries.split("&"):
                 if isinstance(query, list) or isinstance(query, dict):
                    try:
                        query = json.dumps(query)
                    except:
                        pass
                 if '=' in query:
                    headersplit=query.split('=')
                    params[requests.utils.quote(headersplit[0].strip())] = requests.utils.quote(headersplit[1].strip())
                 else:
                    params[requests.utils.quote(query.strip())] = None
        params = '&'.join([k if v is None else f"{k}={v}" for k, v in params.items()])
        try:
            body = " ".join(body.strip().split()).encode("utf-8")
        except:
            pass


        if str(to_file).lower() == "true":
            to_file = True
        else:
            to_file = False

        if "http:/" in url and not "http://" in url:
            url = url.replace("http:/", "http://", -1)
        if "https:/" in url and not "https://" in url:
            url = url.replace("https:/", "https://", -1)
        if "http:///" in url:
            url = url.replace("http:///", "http://", -1)
        if "https:///" in url:
            url = url.replace("https:///", "https://", -1)
        if not "http://" in url and not "http" in url:
            url = f"http://{url}"

        try:
            body = json.dumps(body)
        except:
            pass

        found = False
        contentType = ""
        for key, value in request_headers.items():
            if key.lower() == "user-agent":
                found = True
            if key.lower() == "content-type":
                contentType = key

        if len(contentType) > 0:
            pass

        if not found:
            request_headers["User-Agent"] = "Shuffle Automation"

        try:
            #parsed_headers = [sys.stdout.write(f" -H \"{key}: {value}\"") for key, value in request_headers.items()]
            parsed_headers = ""
            parsed_curl_command = f"curl -XDELETE {url} {parsed_headers}"
            parsed_curl_command += f""" -d '{body}'""" if isinstance(body, str) else f""" -d '{body.decode("utf-8")}'"""

            self.action["parameters"].append({
                "name": "shuffle_request_url",
                "value": f"{url}",
            })
            self.action["parameters"].append({
                "name": "shuffle_request_curl",
                "value": f"{parsed_curl_command}",
            })
            self.action["parameters"].append({
                "name": "shuffle_request_headers",
                "value": f"{json.dumps(parsed_headers)}",
            })

            self.action_result["action"] = self.action
            print("[DEBUG] Updated values in self.action_result from OpenAPI app! (1)")
        except Exception as e:
            print(f"[WARNING] Something went wrong when adding extra returns (1). {e}")

        session = requests.Session()
        ret = session.delete(url, headers=request_headers, params=params, data=body, verify=ssl_verify)
        try:
            found = False
            for item in self.action["parameters"]:
                if item["name"] == "shuffle_response_status":
                    found = True
                    break

            if not found:
                self.action["parameters"].append({
                    "name": "shuffle_response_status",
                    "value": f"{ret.status_code}",
                })
                self.action["parameters"].append({
                    "name": "shuffle_response_length",
                    "value": f"{len(ret.text)}",
                })
                self.action["parameters"].append({
                    "name": "shuffle_request_cookies",
                    "value": f"{json.dumps(session.cookies.get_dict())}",
                })
                print("[DEBUG] Updated values in self.action_result from OpenAPI app! (2)")

        except Exception as e:
            print(f"[WARNING] Something went wrong when adding extra returns (2). {e}")

        if to_file:
            # If content encoding or transfer encoding is base64, decode it
            if ("content-encoding" in ret.headers.keys() and "base64" in ret.headers["content-encoding"].lower()) or ("transfer-encoding" in ret.headers.keys() and "base64" in ret.headers["transfer-encoding"].lower()) or ("content-transfer-encoding" in ret.headers.keys() and "base64" in ret.headers["content-transfer-encoding"].lower()):
                print("[DEBUG] Content encoding is base64, decoding it")
                ret.content = base64.b64decode(ret.content)


            filedata = {
                "filename": "response",
                "data": ret.content,
            }

            fileret = self.set_files([filedata])
            if len(fileret) == 1:
                return {"success": True, "file_id": fileret[0], "status": ret.status_code}

            return fileret

        if not to_file:
            return self.prepare_response(ret)

        return ret.text

    def post_update_a_rule(self, apikey, url, id, headers="", queries="", rule="", body="", ssl_verify=False, to_file=False):#-
        print(f"Started function post_update_a_rule")
        params={}
        request_headers={}
        url=f"{url}/analytics/rules/{id}"
        ssl_verify = True if str(ssl_verify).lower() == "true" or ssl_verify == "1" else False


        if apikey != " ": request_headers["SEC"] = apikey
        if isinstance(headers, dict):
            request_headers = headers
        elif len(headers) > 0:
            for header in str(headers).split("\n"):
                if ':' in header:
                    headersplit=header.split(':')
                    request_headers[headersplit[0].strip()] = ':'.join(headersplit[1:]).strip()
                elif '=' in header:
                    headersplit=header.split('=')
                    request_headers[headersplit[0].strip()] = '='.join(headersplit[1:]).strip()

        if rule:
            if isinstance(rule, list) or isinstance(rule, dict):
                try:
                    rule = json.dumps(rule)
                except:
                    pass

            params[requests.utils.quote("rule")] = requests.utils.quote(rule)

        if len(queries) > 0:
            if queries[0] == "?" or queries[0] == "&":
                queries = queries[1:len(queries)]
            if queries[len(queries)-1] == "?" or queries[len(queries)-1] == "&":
                queries = queries[0:-1]
            for query in queries.split("&"):
                 if isinstance(query, list) or isinstance(query, dict):
                    try:
                        query = json.dumps(query)
                    except:
                        pass
                 if '=' in query:
                    headersplit=query.split('=')
                    params[requests.utils.quote(headersplit[0].strip())] = requests.utils.quote(headersplit[1].strip())
                 else:
                    params[requests.utils.quote(query.strip())] = None
        params = '&'.join([k if v is None else f"{k}={v}" for k, v in params.items()])
        try:
            body = " ".join(body.strip().split()).encode("utf-8")
        except:
            pass


        if str(to_file).lower() == "true":
            to_file = True
        else:
            to_file = False

        if "http:/" in url and not "http://" in url:
            url = url.replace("http:/", "http://", -1)
        if "https:/" in url and not "https://" in url:
            url = url.replace("https:/", "https://", -1)
        if "http:///" in url:
            url = url.replace("http:///", "http://", -1)
        if "https:///" in url:
            url = url.replace("https:///", "https://", -1)
        if not "http://" in url and not "http" in url:
            url = f"http://{url}"

        try:
            body = json.dumps(body)
        except:
            pass

        found = False
        contentType = ""
        for key, value in request_headers.items():
            if key.lower() == "user-agent":
                found = True
            if key.lower() == "content-type":
                contentType = key

        if len(contentType) > 0:
            pass

        if not found:
            request_headers["User-Agent"] = "Shuffle Automation"

        try:
            #parsed_headers = [sys.stdout.write(f" -H \"{key}: {value}\"") for key, value in request_headers.items()]
            parsed_headers = ""
            parsed_curl_command = f"curl -XPOST {url} {parsed_headers}"
            parsed_curl_command += f""" -d '{body}'""" if isinstance(body, str) else f""" -d '{body.decode("utf-8")}'"""

            self.action["parameters"].append({
                "name": "shuffle_request_url",
                "value": f"{url}",
            })
            self.action["parameters"].append({
                "name": "shuffle_request_curl",
                "value": f"{parsed_curl_command}",
            })
            self.action["parameters"].append({
                "name": "shuffle_request_headers",
                "value": f"{json.dumps(parsed_headers)}",
            })

            self.action_result["action"] = self.action
            print("[DEBUG] Updated values in self.action_result from OpenAPI app! (1)")
        except Exception as e:
            print(f"[WARNING] Something went wrong when adding extra returns (1). {e}")

        session = requests.Session()
        ret = session.post(url, headers=request_headers, params=params, data=body, verify=ssl_verify)
        try:
            found = False
            for item in self.action["parameters"]:
                if item["name"] == "shuffle_response_status":
                    found = True
                    break

            if not found:
                self.action["parameters"].append({
                    "name": "shuffle_response_status",
                    "value": f"{ret.status_code}",
                })
                self.action["parameters"].append({
                    "name": "shuffle_response_length",
                    "value": f"{len(ret.text)}",
                })
                self.action["parameters"].append({
                    "name": "shuffle_request_cookies",
                    "value": f"{json.dumps(session.cookies.get_dict())}",
                })
                print("[DEBUG] Updated values in self.action_result from OpenAPI app! (2)")

        except Exception as e:
            print(f"[WARNING] Something went wrong when adding extra returns (2). {e}")

        if to_file:
            # If content encoding or transfer encoding is base64, decode it
            if ("content-encoding" in ret.headers.keys() and "base64" in ret.headers["content-encoding"].lower()) or ("transfer-encoding" in ret.headers.keys() and "base64" in ret.headers["transfer-encoding"].lower()) or ("content-transfer-encoding" in ret.headers.keys() and "base64" in ret.headers["content-transfer-encoding"].lower()):
                print("[DEBUG] Content encoding is base64, decoding it")
                ret.content = base64.b64decode(ret.content)


            filedata = {
                "filename": "response",
                "data": ret.content,
            }

            fileret = self.set_files([filedata])
            if len(fileret) == 1:
                return {"success": True, "file_id": fileret[0], "status": ret.status_code}

            return fileret

        if not to_file:
            return self.prepare_response(ret)

        return ret.text

    def get_authorized_services(self, apikey, url, headers="", queries="", current_authorized_service="", fields="", filter="", ssl_verify=False, to_file=False):#-
        print(f"Started function get_authorized_services")
        params={}
        request_headers={"Accept": "application/json","Content-Type": "application/json"}
        url=f"{url}/config/access/authorized_services"
        ssl_verify = True if str(ssl_verify).lower() == "true" or ssl_verify == "1" else False


        if apikey != " ": request_headers["SEC"] = apikey
        if isinstance(headers, dict):
            request_headers = headers
        elif len(headers) > 0:
            for header in str(headers).split("\n"):
                if ':' in header:
                    headersplit=header.split(':')
                    request_headers[headersplit[0].strip()] = ':'.join(headersplit[1:]).strip()
                elif '=' in header:
                    headersplit=header.split('=')
                    request_headers[headersplit[0].strip()] = '='.join(headersplit[1:]).strip()

        if current_authorized_service:
            if isinstance(current_authorized_service, list) or isinstance(current_authorized_service, dict):
                try:
                    current_authorized_service = json.dumps(current_authorized_service)
                except:
                    pass

            params[requests.utils.quote("current_authorized_service")] = requests.utils.quote(current_authorized_service)
        if fields:
            if isinstance(fields, list) or isinstance(fields, dict):
                try:
                    fields = json.dumps(fields)
                except:
                    pass

            params[requests.utils.quote("fields")] = requests.utils.quote(fields)
        if filter:
            if isinstance(filter, list) or isinstance(filter, dict):
                try:
                    filter = json.dumps(filter)
                except:
                    pass

            params[requests.utils.quote("filter")] = requests.utils.quote(filter)

        if len(queries) > 0:
            if queries[0] == "?" or queries[0] == "&":
                queries = queries[1:len(queries)]
            if queries[len(queries)-1] == "?" or queries[len(queries)-1] == "&":
                queries = queries[0:-1]
            for query in queries.split("&"):
                 if isinstance(query, list) or isinstance(query, dict):
                    try:
                        query = json.dumps(query)
                    except:
                        pass
                 if '=' in query:
                    headersplit=query.split('=')
                    params[requests.utils.quote(headersplit[0].strip())] = requests.utils.quote(headersplit[1].strip())
                 else:
                    params[requests.utils.quote(query.strip())] = None
        params = '&'.join([k if v is None else f"{k}={v}" for k, v in params.items()])



        if str(to_file).lower() == "true":
            to_file = True
        else:
            to_file = False

        if "http:/" in url and not "http://" in url:
            url = url.replace("http:/", "http://", -1)
        if "https:/" in url and not "https://" in url:
            url = url.replace("https:/", "https://", -1)
        if "http:///" in url:
            url = url.replace("http:///", "http://", -1)
        if "https:///" in url:
            url = url.replace("https:///", "https://", -1)
        if not "http://" in url and not "http" in url:
            url = f"http://{url}"

        try:
            body = json.dumps(body)
        except:
            pass

        found = False
        contentType = ""
        for key, value in request_headers.items():
            if key.lower() == "user-agent":
                found = True
            if key.lower() == "content-type":
                contentType = key

        if len(contentType) > 0:
            pass

        if not found:
            request_headers["User-Agent"] = "Shuffle Automation"

        try:
            #parsed_headers = [sys.stdout.write(f" -H \"{key}: {value}\"") for key, value in request_headers.items()]
            parsed_headers = ""
            parsed_curl_command = f"curl -XGET {url} {parsed_headers}"


            self.action["parameters"].append({
                "name": "shuffle_request_url",
                "value": f"{url}",
            })
            self.action["parameters"].append({
                "name": "shuffle_request_curl",
                "value": f"{parsed_curl_command}",
            })
            self.action["parameters"].append({
                "name": "shuffle_request_headers",
                "value": f"{json.dumps(parsed_headers)}",
            })

            self.action_result["action"] = self.action
            print("[DEBUG] Updated values in self.action_result from OpenAPI app! (1)")
        except Exception as e:
            print(f"[WARNING] Something went wrong when adding extra returns (1). {e}")

        session = requests.Session()
        ret = session.get(url, headers=request_headers, params=params, verify=ssl_verify)
        try:
            found = False
            for item in self.action["parameters"]:
                if item["name"] == "shuffle_response_status":
                    found = True
                    break

            if not found:
                self.action["parameters"].append({
                    "name": "shuffle_response_status",
                    "value": f"{ret.status_code}",
                })
                self.action["parameters"].append({
                    "name": "shuffle_response_length",
                    "value": f"{len(ret.text)}",
                })
                self.action["parameters"].append({
                    "name": "shuffle_request_cookies",
                    "value": f"{json.dumps(session.cookies.get_dict())}",
                })
                print("[DEBUG] Updated values in self.action_result from OpenAPI app! (2)")

        except Exception as e:
            print(f"[WARNING] Something went wrong when adding extra returns (2). {e}")

        if to_file:
            # If content encoding or transfer encoding is base64, decode it
            if ("content-encoding" in ret.headers.keys() and "base64" in ret.headers["content-encoding"].lower()) or ("transfer-encoding" in ret.headers.keys() and "base64" in ret.headers["transfer-encoding"].lower()) or ("content-transfer-encoding" in ret.headers.keys() and "base64" in ret.headers["content-transfer-encoding"].lower()):
                print("[DEBUG] Content encoding is base64, decoding it")
                ret.content = base64.b64decode(ret.content)


            filedata = {
                "filename": "response",
                "data": ret.content,
            }

            fileret = self.set_files([filedata])
            if len(fileret) == 1:
                return {"success": True, "file_id": fileret[0], "status": ret.status_code}

            return fileret

        if not to_file:
            return self.prepare_response(ret)

        return ret.text

    def post_create_an_authorized_services(self, apikey, url, authorized_service, headers="", queries="", body="", ssl_verify=False, to_file=False):#-
        print(f"Started function post_create_an_authorized_services")
        params={}
        request_headers={}
        url=f"{url}/config/access/authorized_services"
        ssl_verify = True if str(ssl_verify).lower() == "true" or ssl_verify == "1" else False


        if apikey != " ": request_headers["SEC"] = apikey
        if isinstance(headers, dict):
            request_headers = headers
        elif len(headers) > 0:
            for header in str(headers).split("\n"):
                if ':' in header:
                    headersplit=header.split(':')
                    request_headers[headersplit[0].strip()] = ':'.join(headersplit[1:]).strip()
                elif '=' in header:
                    headersplit=header.split('=')
                    request_headers[headersplit[0].strip()] = '='.join(headersplit[1:]).strip()

        if authorized_service:
            if isinstance(authorized_service, list) or isinstance(authorized_service, dict):
                try:
                    authorized_service = json.dumps(authorized_service)
                except:
                    pass

            params[requests.utils.quote("authorized_service")] = requests.utils.quote(authorized_service)

        if len(queries) > 0:
            if queries[0] == "?" or queries[0] == "&":
                queries = queries[1:len(queries)]
            if queries[len(queries)-1] == "?" or queries[len(queries)-1] == "&":
                queries = queries[0:-1]
            for query in queries.split("&"):
                 if isinstance(query, list) or isinstance(query, dict):
                    try:
                        query = json.dumps(query)
                    except:
                        pass
                 if '=' in query:
                    headersplit=query.split('=')
                    params[requests.utils.quote(headersplit[0].strip())] = requests.utils.quote(headersplit[1].strip())
                 else:
                    params[requests.utils.quote(query.strip())] = None
        params = '&'.join([k if v is None else f"{k}={v}" for k, v in params.items()])
        try:
            body = " ".join(body.strip().split()).encode("utf-8")
        except:
            pass


        if str(to_file).lower() == "true":
            to_file = True
        else:
            to_file = False

        if "http:/" in url and not "http://" in url:
            url = url.replace("http:/", "http://", -1)
        if "https:/" in url and not "https://" in url:
            url = url.replace("https:/", "https://", -1)
        if "http:///" in url:
            url = url.replace("http:///", "http://", -1)
        if "https:///" in url:
            url = url.replace("https:///", "https://", -1)
        if not "http://" in url and not "http" in url:
            url = f"http://{url}"

        try:
            body = json.dumps(body)
        except:
            pass

        found = False
        contentType = ""
        for key, value in request_headers.items():
            if key.lower() == "user-agent":
                found = True
            if key.lower() == "content-type":
                contentType = key

        if len(contentType) > 0:
            pass

        if not found:
            request_headers["User-Agent"] = "Shuffle Automation"

        try:
            #parsed_headers = [sys.stdout.write(f" -H \"{key}: {value}\"") for key, value in request_headers.items()]
            parsed_headers = ""
            parsed_curl_command = f"curl -XPOST {url} {parsed_headers}"
            parsed_curl_command += f""" -d '{body}'""" if isinstance(body, str) else f""" -d '{body.decode("utf-8")}'"""

            self.action["parameters"].append({
                "name": "shuffle_request_url",
                "value": f"{url}",
            })
            self.action["parameters"].append({
                "name": "shuffle_request_curl",
                "value": f"{parsed_curl_command}",
            })
            self.action["parameters"].append({
                "name": "shuffle_request_headers",
                "value": f"{json.dumps(parsed_headers)}",
            })

            self.action_result["action"] = self.action
            print("[DEBUG] Updated values in self.action_result from OpenAPI app! (1)")
        except Exception as e:
            print(f"[WARNING] Something went wrong when adding extra returns (1). {e}")

        session = requests.Session()
        ret = session.post(url, headers=request_headers, params=params, data=body, verify=ssl_verify)
        try:
            found = False
            for item in self.action["parameters"]:
                if item["name"] == "shuffle_response_status":
                    found = True
                    break

            if not found:
                self.action["parameters"].append({
                    "name": "shuffle_response_status",
                    "value": f"{ret.status_code}",
                })
                self.action["parameters"].append({
                    "name": "shuffle_response_length",
                    "value": f"{len(ret.text)}",
                })
                self.action["parameters"].append({
                    "name": "shuffle_request_cookies",
                    "value": f"{json.dumps(session.cookies.get_dict())}",
                })
                print("[DEBUG] Updated values in self.action_result from OpenAPI app! (2)")

        except Exception as e:
            print(f"[WARNING] Something went wrong when adding extra returns (2). {e}")

        if to_file:
            # If content encoding or transfer encoding is base64, decode it
            if ("content-encoding" in ret.headers.keys() and "base64" in ret.headers["content-encoding"].lower()) or ("transfer-encoding" in ret.headers.keys() and "base64" in ret.headers["transfer-encoding"].lower()) or ("content-transfer-encoding" in ret.headers.keys() and "base64" in ret.headers["content-transfer-encoding"].lower()):
                print("[DEBUG] Content encoding is base64, decoding it")
                ret.content = base64.b64decode(ret.content)


            filedata = {
                "filename": "response",
                "data": ret.content,
            }

            fileret = self.set_files([filedata])
            if len(fileret) == 1:
                return {"success": True, "file_id": fileret[0], "status": ret.status_code}

            return fileret

        if not to_file:
            return self.prepare_response(ret)

        return ret.text

    def get_offense(self, apikey, url, offence_id, headers="", queries="", ssl_verify=False, to_file=False):#
        print(f"Started function get_offense")
        params={}
        request_headers={}
        url=f"{url}/siem/offenses/{offence_id}"
        ssl_verify = True if str(ssl_verify).lower() == "true" or ssl_verify == "1" else False


        if apikey != " ": request_headers["SEC"] = apikey
        if isinstance(headers, dict):
            request_headers = headers
        elif len(headers) > 0:
            for header in str(headers).split("\n"):
                if ':' in header:
                    headersplit=header.split(':')
                    request_headers[headersplit[0].strip()] = ':'.join(headersplit[1:]).strip()
                elif '=' in header:
                    headersplit=header.split('=')
                    request_headers[headersplit[0].strip()] = '='.join(headersplit[1:]).strip()


        if len(queries) > 0:
            if queries[0] == "?" or queries[0] == "&":
                queries = queries[1:len(queries)]
            if queries[len(queries)-1] == "?" or queries[len(queries)-1] == "&":
                queries = queries[0:-1]
            for query in queries.split("&"):
                 if isinstance(query, list) or isinstance(query, dict):
                    try:
                        query = json.dumps(query)
                    except:
                        pass
                 if '=' in query:
                    headersplit=query.split('=')
                    params[requests.utils.quote(headersplit[0].strip())] = requests.utils.quote(headersplit[1].strip())
                 else:
                    params[requests.utils.quote(query.strip())] = None
        params = '&'.join([k if v is None else f"{k}={v}" for k, v in params.items()])



        if str(to_file).lower() == "true":
            to_file = True
        else:
            to_file = False

        if "http:/" in url and not "http://" in url:
            url = url.replace("http:/", "http://", -1)
        if "https:/" in url and not "https://" in url:
            url = url.replace("https:/", "https://", -1)
        if "http:///" in url:
            url = url.replace("http:///", "http://", -1)
        if "https:///" in url:
            url = url.replace("https:///", "https://", -1)
        if not "http://" in url and not "http" in url:
            url = f"http://{url}"

        try:
            body = json.dumps(body)
        except:
            pass

        found = False
        contentType = ""
        for key, value in request_headers.items():
            if key.lower() == "user-agent":
                found = True
            if key.lower() == "content-type":
                contentType = key

        if len(contentType) > 0:
            pass

        if not found:
            request_headers["User-Agent"] = "Shuffle Automation"

        try:
            #parsed_headers = [sys.stdout.write(f" -H \"{key}: {value}\"") for key, value in request_headers.items()]
            parsed_headers = ""
            parsed_curl_command = f"curl -XGET {url} {parsed_headers}"


            self.action["parameters"].append({
                "name": "shuffle_request_url",
                "value": f"{url}",
            })
            self.action["parameters"].append({
                "name": "shuffle_request_curl",
                "value": f"{parsed_curl_command}",
            })
            self.action["parameters"].append({
                "name": "shuffle_request_headers",
                "value": f"{json.dumps(parsed_headers)}",
            })

            self.action_result["action"] = self.action
            print("[DEBUG] Updated values in self.action_result from OpenAPI app! (1)")
        except Exception as e:
            print(f"[WARNING] Something went wrong when adding extra returns (1). {e}")

        session = requests.Session()
        ret = session.get(url, headers=request_headers, params=params, verify=ssl_verify)
        try:
            found = False
            for item in self.action["parameters"]:
                if item["name"] == "shuffle_response_status":
                    found = True
                    break

            if not found:
                self.action["parameters"].append({
                    "name": "shuffle_response_status",
                    "value": f"{ret.status_code}",
                })
                self.action["parameters"].append({
                    "name": "shuffle_response_length",
                    "value": f"{len(ret.text)}",
                })
                self.action["parameters"].append({
                    "name": "shuffle_request_cookies",
                    "value": f"{json.dumps(session.cookies.get_dict())}",
                })
                print("[DEBUG] Updated values in self.action_result from OpenAPI app! (2)")

        except Exception as e:
            print(f"[WARNING] Something went wrong when adding extra returns (2). {e}")

        if to_file:
            # If content encoding or transfer encoding is base64, decode it
            if ("content-encoding" in ret.headers.keys() and "base64" in ret.headers["content-encoding"].lower()) or ("transfer-encoding" in ret.headers.keys() and "base64" in ret.headers["transfer-encoding"].lower()) or ("content-transfer-encoding" in ret.headers.keys() and "base64" in ret.headers["content-transfer-encoding"].lower()):
                print("[DEBUG] Content encoding is base64, decoding it")
                ret.content = base64.b64decode(ret.content)


            filedata = {
                "filename": "response",
                "data": ret.content,
            }

            fileret = self.set_files([filedata])
            if len(fileret) == 1:
                return {"success": True, "file_id": fileret[0], "status": ret.status_code}

            return fileret

        if not to_file:
            return self.prepare_response(ret)

        return ret.text

    def post_close_offense(self, apikey, url, offense_id, headers="", queries="", body="", ssl_verify=False, to_file=False):#
        print(f"Started function post_close_offense")
        params={}
        request_headers={}
        url=f"{url}/siem/offenses/{offense_id}"
        ssl_verify = True if str(ssl_verify).lower() == "true" or ssl_verify == "1" else False


        if apikey != " ": request_headers["SEC"] = apikey
        if isinstance(headers, dict):
            request_headers = headers
        elif len(headers) > 0:
            for header in str(headers).split("\n"):
                if ':' in header:
                    headersplit=header.split(':')
                    request_headers[headersplit[0].strip()] = ':'.join(headersplit[1:]).strip()
                elif '=' in header:
                    headersplit=header.split('=')
                    request_headers[headersplit[0].strip()] = '='.join(headersplit[1:]).strip()


        if len(queries) > 0:
            if queries[0] == "?" or queries[0] == "&":
                queries = queries[1:len(queries)]
            if queries[len(queries)-1] == "?" or queries[len(queries)-1] == "&":
                queries = queries[0:-1]
            for query in queries.split("&"):
                 if isinstance(query, list) or isinstance(query, dict):
                    try:
                        query = json.dumps(query)
                    except:
                        pass
                 if '=' in query:
                    headersplit=query.split('=')
                    params[requests.utils.quote(headersplit[0].strip())] = requests.utils.quote(headersplit[1].strip())
                 else:
                    params[requests.utils.quote(query.strip())] = None
        params = '&'.join([k if v is None else f"{k}={v}" for k, v in params.items()])
        try:
            body = " ".join(body.strip().split()).encode("utf-8")
        except:
            pass


        if str(to_file).lower() == "true":
            to_file = True
        else:
            to_file = False

        if "http:/" in url and not "http://" in url:
            url = url.replace("http:/", "http://", -1)
        if "https:/" in url and not "https://" in url:
            url = url.replace("https:/", "https://", -1)
        if "http:///" in url:
            url = url.replace("http:///", "http://", -1)
        if "https:///" in url:
            url = url.replace("https:///", "https://", -1)
        if not "http://" in url and not "http" in url:
            url = f"http://{url}"

        try:
            body = json.dumps(body)
        except:
            pass

        found = False
        contentType = ""
        for key, value in request_headers.items():
            if key.lower() == "user-agent":
                found = True
            if key.lower() == "content-type":
                contentType = key

        if len(contentType) > 0:
            pass

        if not found:
            request_headers["User-Agent"] = "Shuffle Automation"

        try:
            #parsed_headers = [sys.stdout.write(f" -H \"{key}: {value}\"") for key, value in request_headers.items()]
            parsed_headers = ""
            parsed_curl_command = f"curl -XPOST {url} {parsed_headers}"
            parsed_curl_command += f""" -d '{body}'""" if isinstance(body, str) else f""" -d '{body.decode("utf-8")}'"""

            self.action["parameters"].append({
                "name": "shuffle_request_url",
                "value": f"{url}",
            })
            self.action["parameters"].append({
                "name": "shuffle_request_curl",
                "value": f"{parsed_curl_command}",
            })
            self.action["parameters"].append({
                "name": "shuffle_request_headers",
                "value": f"{json.dumps(parsed_headers)}",
            })

            self.action_result["action"] = self.action
            print("[DEBUG] Updated values in self.action_result from OpenAPI app! (1)")
        except Exception as e:
            print(f"[WARNING] Something went wrong when adding extra returns (1). {e}")

        session = requests.Session()
        ret = session.post(url, headers=request_headers, params=params, data=body, verify=ssl_verify)
        try:
            found = False
            for item in self.action["parameters"]:
                if item["name"] == "shuffle_response_status":
                    found = True
                    break

            if not found:
                self.action["parameters"].append({
                    "name": "shuffle_response_status",
                    "value": f"{ret.status_code}",
                })
                self.action["parameters"].append({
                    "name": "shuffle_response_length",
                    "value": f"{len(ret.text)}",
                })
                self.action["parameters"].append({
                    "name": "shuffle_request_cookies",
                    "value": f"{json.dumps(session.cookies.get_dict())}",
                })
                print("[DEBUG] Updated values in self.action_result from OpenAPI app! (2)")

        except Exception as e:
            print(f"[WARNING] Something went wrong when adding extra returns (2). {e}")

        if to_file:
            # If content encoding or transfer encoding is base64, decode it
            if ("content-encoding" in ret.headers.keys() and "base64" in ret.headers["content-encoding"].lower()) or ("transfer-encoding" in ret.headers.keys() and "base64" in ret.headers["transfer-encoding"].lower()) or ("content-transfer-encoding" in ret.headers.keys() and "base64" in ret.headers["content-transfer-encoding"].lower()):
                print("[DEBUG] Content encoding is base64, decoding it")
                ret.content = base64.b64decode(ret.content)


            filedata = {
                "filename": "response",
                "data": ret.content,
            }

            fileret = self.set_files([filedata])
            if len(fileret) == 1:
                return {"success": True, "file_id": fileret[0], "status": ret.status_code}

            return fileret

        if not to_file:
            return self.prepare_response(ret)

        return ret.text


    def fix_url(self, url, path=False):
        if "hhttp" in url:
            url = url.replace("hhttp", "http")

        if url.startswith("http//"):
            url = url.replace("http//", "http://")
        if url.startswith("https//"):
            url = url.replace("https//", "https://")

        if "http:/" in url and not "http://" in url:
            url = url.replace("http:/", "http://", -1)
        if "https:/" in url and not "https://" in url:
            url = url.replace("https:/", "https://", -1)
        if "http:///" in url:
            url = url.replace("http:///", "http://", -1)
        if "https:///" in url:
            url = url.replace("https:///", "https://", -1)
        if not path and not "http://" in url and not "http" in url:
            url = f"http://{url}"

        return url


    def checkverify(self, verify):
        if str(verify).lower().strip() == "false":
            return False
        elif verify is None:
            return False
        elif verify:
            return True
        elif not verify:
            return False
        else:
            return True


    def is_valid_method(self, method):
        valid_methods = ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS", "HEAD"]
        method = method.upper()

        if method in valid_methods:
            return method
        else:
            raise ValueError(f"Invalid HTTP method: {method}")


    def parse_headers(self, headers):
        parsed_headers = {}
        if headers:
            split_headers = headers.split("\n")
            self.logger.info(split_headers)
            for header in split_headers:
                if ":" in header:
                    splititem = ":"
                elif "=" in header:
                    splititem = "="
                else:
                    continue

                splitheader = header.split(splititem)
                if len(splitheader) >= 2:
                    parsed_headers[splitheader[0].strip()] = splititem.join(
                        splitheader[1:]
                    ).strip()
                else:
                    continue

        return parsed_headers


    def parse_queries(self, queries):
        parsed_queries = {}

        if not queries:
            return parsed_queries

        cleaned_queries = queries.strip()

        if not cleaned_queries:
            return parsed_queries

        cleaned_queries = " ".join(cleaned_queries.split())
        splitted_queries = cleaned_queries.split("&")
        self.logger.info(splitted_queries)
        for query in splitted_queries:

            if "=" not in query:
                self.logger.info("Skipping as there is no = in the query")
                continue
            key, value = query.split("=")
            if not key.strip() or not value.strip():
                self.logger.info(
                    "Skipping because either key or value is not present in query"
                )
                continue
            parsed_queries[key.strip()] = value.strip()

        return parsed_queries

    def prepare_response(self, request):
        try:
            parsedheaders = {}
            for key, value in request.headers.items():
                parsedheaders[key] = value

            cookies = {}
            if request.cookies:
                for key, value in request.cookies.items():
                    cookies[key] = value


            jsondata = request.text
            try:
                jsondata = json.loads(jsondata)
            except:
                pass

            parseddata = {
                "status": request.status_code,
                "body": jsondata,
                "url": request.url,
                "headers": parsedheaders,
                "cookies":cookies,
                "success": True,
            }

            return json.dumps(parseddata)
        except Exception as e:
            print(f"[WARNING] Failed in request: {e}")
            return request.text


    def custom_action(self, apikey, method="", url="", headers="", queries="", path="", ssl_verify=False, body=""):#
        url = self.fix_url(url)

        try:
            method = self.is_valid_method(method)
        except ValueError as e:
            self.logger.error(e)
            return {"error": str(e)}

        if not path:
            path = "/"

        path = self.fix_url(path, path=True)
        if path and path.startswith(url):
            path = path.replace(url, "", 1)

        if path and not path.startswith('/'):
            path = '/' + path

        url += path

        parsed_headers = {}
        parsed_queries = {}

        if apikey != " ": parsed_headers["SEC"] = apikey

        # Allows overwriting of existing headers with custom input ones
        additional_headers = self.parse_headers(headers)
        try:
            parsed_headers.update(additional_headers)
        except Exception as e:
            print(f"Header parse error: {e}")

        additional_queries = self.parse_queries(queries)
        try:
            parsed_queries.update(additional_queries)
        except Exception as e:
            print(f"Query parse error: {e}")

        ssl_verify = self.checkverify(ssl_verify)

        if isinstance(body, dict):
            try:
                body = json.dumps(body)
            except json.JSONDecodeError as e:
                self.logger.error(f"error : {e}")
                return {"error: Invalid JSON format for request body"}

        try:
            response = requests.request(method, url, headers=parsed_headers, params=parsed_queries, data=body, verify=ssl_verify) #response.raise_for_status()

            return self.prepare_response(response)

        except requests.RequestException as e:
            self.logger.error(f"Request failed: {e}")
            return {"error": f"Request failed: {e}"}


if __name__ == "__main__":
    QRadard5e4fa5a354b86670e3f039ace5141f5.run()